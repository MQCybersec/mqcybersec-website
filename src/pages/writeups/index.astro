---
import { getCollection } from "astro:content";
import Header from "~/components/header.astro";
import Footer from "~/components/footer.astro";
import WriteupCard from "~/components/writeups/WriteupCard.astro";
import ContentSection from "~/components/content-section.astro";
import "~/styles/index.css";
import LogoBlock from "~/components/logo-block.astro";
import { Icon } from "astro-icon/components";
import { Image } from "astro:assets";
import { extractTagSuggestions } from "~/utils/auto-hyperlink";
const { generator, site } = Astro;

// Get all writeups and sort by date, filter out hidden ones
const allWriteups = await getCollection("writeups");
const writeups = allWriteups.filter((writeup) => !writeup.data.hidden);

// First pass: Apply tags to writeups without tags
writeups.forEach((writeup) => {
  // If the writeup has no tags, extract and assign tags from content
  if (!writeup.data.tags || writeup.data.tags.length === 0) {
    const suggestedTags = extractTagSuggestions(writeup.body, []);

    // Use up to 5 suggested tags
    if (suggestedTags.length > 0) {
      writeup.data.tags = suggestedTags.slice(0, 5);
    } else {
      // Initialize with empty array if no suggestions found
      writeup.data.tags = [];
    }
  }
});

// Sort writeups by date after tag assignment
const sortedWriteups = writeups.sort(
  (a, b) => b.data.pubDate.valueOf() - a.data.pubDate.valueOf(),
);

// Collect all tags and their frequencies
const tagFrequencyMap = new Map();
sortedWriteups.forEach((writeup) => {
  // Add regular tags
  (writeup.data.tags || []).forEach((tag) => {
    tagFrequencyMap.set(tag, (tagFrequencyMap.get(tag) || 0) + 1);
  });
  
  // Extract and add suggested tags
  if (!writeup.data.tags || writeup.data.tags.length < 3) {
    const suggestedTags = extractTagSuggestions(writeup.body, writeup.data.tags || []).slice(0, 3);
    suggestedTags.forEach((tag) => {
      // Suggested tags get a lower frequency weight (0.5) to rank them lower than regular tags
      tagFrequencyMap.set(tag, (tagFrequencyMap.get(tag) || 0) + 0.5);
    });
  }
});


// Get tags sorted by frequency for UI
const tags = [...tagFrequencyMap.entries()]
  .sort((a, b) => b[1] - a[1])
  .map((entry) => ({
    name: entry[0],
    frequency: Math.round(entry[1]),
    isSuggested: entry[1] % 1 !== 0 // If frequency has a decimal part, it's a suggested tag
  }));

// Categories for filtering
const categories = [
  ...new Set(writeups.map((post) => post.data.category).filter(Boolean)),
];
const ctfs = [
  ...new Set(writeups.map((post) => post.data.ctf).filter(Boolean)),
];

// Get all sections from the sections collection with their icons/images
const sectionCollection = await getCollection("sections");
const sectionsMap = new Map();

// Process sections from the section collection
sectionCollection.forEach((section) => {
  sectionsMap.set(section.data.name, {
    icon: section.data.icon || null,
    iconImage: section.data.iconImage || null,
    color: section.data.color || null
  });
});

// Get unique sections from writeups
const sectionNames = [
  ...new Set(writeups.map((post) => post.data.section).filter(Boolean)),
];

// Create a formatted sections array with icon information
const sections = sectionNames.map((name) => {
  const sectionInfo = sectionsMap.get(name) || { icon: null, iconImage: null, color: null };
  return {
    name,
    icon: sectionInfo.icon,
    iconImage: sectionInfo.iconImage,
    color: sectionInfo.color
  };
});

// Detect sections that should have difficulty filters
const hasPicoCTF = sections.some(section => section.name === "PicoCTF");
const hasHackTheBox = sections.some(section => 
  section.name === "HackTheBox Machines" || 
  section.name === "HackTheBox Challenges"
);

// Difficulty info configuration
const difficultyInfo = {
  easy: {
    color: '#4ade80', // green
    bgColor: 'rgba(74, 222, 128, 0.2)',
    icon: 'mdi:shield-check-outline'
  },
  medium: {
    color: '#fb923c', // orange
    bgColor: 'rgba(251, 146, 60, 0.2)',
    icon: 'mdi:shield-alert-outline'
  },
  hard: {
    color: '#f87171', // red
    bgColor: 'rgba(248, 113, 113, 0.2)',
    icon: 'mdi:shield-alert'
  },
  insane: {
    color: '#a1a1aa', // grey
    bgColor: 'rgba(161, 161, 170, 0.2)',
    icon: 'mdi:shield-crown-outline'
  }
};

// Create a searchable index for client-side search
const searchIndex = sortedWriteups.map((writeup) => {
  // Extract suggested tags for this writeup
  const suggestedTags = (!writeup.data.tags || writeup.data.tags.length < 3) 
    ? extractTagSuggestions(writeup.body, writeup.data.tags || []).slice(0, 3)
    : [];
  
  const searchableText = [
    writeup.data.title,
    writeup.data.description,
    writeup.data.ctf,
    writeup.data.category,
    writeup.data.section,
    (writeup.data.tags || []).join(" "),
    writeup.body, // This includes the content for searching
  ]
    .filter(Boolean)
    .join(" ")
    .toLowerCase();

  return {
    slug: writeup.slug,
    searchableText,
    section: writeup.data.section || "",
    tags: writeup.data.tags || [],
    suggestedTags,
    ctf: writeup.data.ctf || "",
    category: writeup.data.category || "",
  };
});

const description = "MQCyberSec CTF writeups and technical guides.";
const title = "CTF Writeups | MQCyberSec";
---

<!doctype html>
<html lang="en" class="h-full motion-safe:scroll-smooth" data-theme="dark">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" href="/favicon.svg" type="image/svg+xml" />
    <meta content="#ec4899" data-react-helmet="true" name="theme-color" />
    <meta name="generator" content={generator} />
    <title>{title}</title>
    <meta name="description" content={description} />

    <meta property="og:title" content="Writeups - MQCyberSec" />
    <meta property="og:type" content="website" />
    <meta property="og:description" content={description} />
    <meta property="og:url" content={site} />

    <script is:inline>
      const themeSaved = localStorage.getItem("theme");

      if (themeSaved) {
        document.documentElement.dataset.theme = themeSaved;
      } else {
        const prefersDark = window.matchMedia(
          "(prefers-color-scheme: dark)",
        ).matches;
        document.documentElement.dataset.theme = prefersDark ? "dark" : "light";
      }
    </script>

    <script
      is:inline
      src="https://cdn.jsdelivr.net/npm/flowbite@2.5.2/dist/flowbite.min.js"
    ></script>
  </head>

  <body
    class="h-full overflow-x-hidden bg-default text-default text-base selection:bg-secondary selection:text-white"
  >
    <Header />

    <main>
      <br />
      <ContentSection title="CTF Writeups" id="writeups">
        <Fragment slot="lead">
          <div class="mx-auto max-w-2xl">
            <p class="text-center font-bold leading-relaxed tracking-tight">
              Explore our collection of <span class="text-primary">{writeups.length} posts</span> for
              <span class="text-primary">Capture The Flag writeups</span> and
              <span class="text-primary">technical guides</span> created by the members and executives of MQCyberSec.
            </p>
          </div>
        </Fragment>

        <div class="mt-8 w-full">
          <!-- Add search field -->
          <div class="mb-8">
            <div class="relative mx-auto w-full max-w-xl">
              <div
                class="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3"
              >
                <Icon name="mdi:magnify" class="text-text-offset size-5" />
              </div>
              <input
                type="search"
                id="search-input"
                class="border-border bg-background-offset text-text placeholder:text-text-offset block w-full rounded-lg border p-4 pl-10 text-sm focus:border-primary focus:ring-primary"
                placeholder="Search writeups content, titles, and tags..."
              />
              <div
                id="search-status"
                class="text-text-offset absolute right-0 top-0 flex hidden h-full items-center pr-4 text-sm"
              >
                Found <span id="result-count" class="mx-1 font-bold">0</span> results
              </div>
            </div>
          </div>

          <!-- Section buttons -->
          {
            sections.length > 0 && (
              <div class="mb-6">
                <h3 class="text-text-offset mb-3 font-medium text-sm">
                  Browse by Section
                </h3>
                <div class="flex flex-wrap gap-2">
                  <button
                    class="section-btn active hover:bg-primary/80 rounded-full bg-primary px-4 py-2 font-medium text-white transition-colors text-sm"
                    data-section=""
                  >
                    All
                  </button>
                  {sections.map((section) => (
                    <button
                      class="section-btn bg-background-offset text-text hover:bg-background-alt rounded-full px-4 py-2 font-medium transition-colors text-sm flex items-center"
                      data-section={section.name}
                      style={section.color ? `background-color: ${section.color}20; color: ${section.color};` : ''}
                    >
                      {section.iconImage ? (
                        <Image 
                          src={section.iconImage}
                          alt={`${section.name} icon`}
                          width={16}
                          height={16}
                          class="mr-1.5"
                        />
                      ) : section.icon ? (
                        <span class="mr-1.5">{section.icon}</span>
                      ) : null}
                      {section.name}
                    </button>
                  ))}
                </div>
              </div>
            )
          }

          <!-- Tags cloud -->
          {
            tags.length > 0 && (
              <div class="mb-6">
                <div class="flex justify-between">
                  <h3 class="text-text-offset mb-3 font-medium text-sm">
                    Filter by Tags
                  </h3>
                  <button
                    id="clear-tags"
                    class="hover:text-primary/80 hidden text-primary text-xs"
                  >
                    Clear selected tags
                  </button>
                </div>
                <div class="mb-2 flex flex-wrap gap-2" id="tags-container">
                  {tags.map((tag) => (
                    <button
                      class={`tag-btn ${tag.isSuggested ? 'border border-dashed border-primary/30 text-text-offset' : 'bg-background-offset text-text-offset'} hover:bg-background-alt rounded-full px-3 py-1 transition-colors text-sm`}
                      data-tag={tag.name}
                      data-suggested={tag.isSuggested}
                    >
                      #{tag.name}
                    </button>
                  ))}
                </div>
              </div>
            )
          }

          <!-- Advanced filters -->
          <div class="mb-8 flex flex-wrap gap-4">
            <div class="sm:flex-1">
              <label
                for="category-filter"
                class="text-text-offset mb-2 block font-medium text-sm"
                >Filter by Category</label
              >
              <select
                id="category-filter"
                class="border-border bg-background-offset text-text w-full rounded border p-2"
              >
                <option value="">All Categories</option>
                {
                  categories.map((category) => (
                    <option value={category}>{category}</option>
                  ))
                }
              </select>
            </div>

            <div class="sm:flex-1">
              <label
                for="ctf-filter"
                class="text-text-offset mb-2 block font-medium text-sm"
                >Filter by CTF</label
              >
              <select
                id="ctf-filter"
                class="border-border bg-background-offset text-text w-full rounded border p-2"
              >
                <option value="">All CTFs</option>
                {ctfs.map((ctf) => <option value={ctf}>{ctf}</option>)}
              </select>
            </div>
          </div>

          <div
            id="writeups-container"
            class="grid grid-cols-1 gap-8 md:grid-cols-2 lg:grid-cols-3"
          >
            {sortedWriteups.map((writeup) => <WriteupCard writeup={writeup} />)}
          </div>

          <!-- No results message -->
          <div id="no-results" class="hidden py-10 text-center">
            <p class="text-text-offset font-bold text-xl">
              No writeups found matching your filters.
            </p>
            <p class="text-text-offset mt-2">
              Try adjusting your search terms, tags, or filters.
            </p>
            <button
              id="reset-filters"
              class="hover:bg-primary/80 mt-4 rounded-lg bg-primary px-4 py-2 text-white transition-colors"
            >
              Reset all filters
            </button>
          </div>
        </div>
      </ContentSection>
    </main>

    <Footer />

    <script define:vars={{ searchIndex, sections, difficultyInfo }}>
      // Client-side filtering and searching
      const categoryFilter = document.getElementById("category-filter");
      const ctfFilter = document.getElementById("ctf-filter");
      const searchInput = document.getElementById("search-input");
      const writeupCards = document.querySelectorAll("[data-writeup-card]");
      const writeupContainer = document.getElementById("writeups-container");
      const noResultsMessage = document.getElementById("no-results");
      const searchStatus = document.getElementById("search-status");
      const resetFiltersBtn = document.getElementById("reset-filters");
      const clearTagsBtn = document.getElementById("clear-tags");
      const sectionBtns = document.querySelectorAll(".section-btn");
      const tagBtns = document.querySelectorAll(".tag-btn");
      const difficultyBtns = document.querySelectorAll(".difficulty-btn");

      let debounceTimeout;
      let selectedTags = [];
      let currentSection = "";
      let currentDifficulty = "";

      function debounce(func, wait) {
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(debounceTimeout);
            func(...args);
          };

          clearTimeout(debounceTimeout);
          debounceTimeout = setTimeout(later, wait);
        };
      }

      // Update UI when tag selection changes
      function updateTagUI() {
        tagBtns.forEach((btn) => {
          const tag = btn.getAttribute("data-tag");
          const isSuggested = btn.getAttribute("data-suggested") === "true";
          
          if (selectedTags.includes(tag)) {
            btn.classList.add("bg-primary", "text-white");
            btn.classList.remove("bg-background-offset", "text-text-offset", "border", "border-dashed", "border-primary/30");
          } else {
            btn.classList.remove("bg-primary", "text-white");
            
            if (isSuggested) {
              btn.classList.add("border", "border-dashed", "border-primary/30", "text-text-offset");
            } else {
              btn.classList.add("bg-background-offset", "text-text-offset");
            }
          }
        });

        if (selectedTags.length > 0) {
          clearTagsBtn.classList.remove("hidden");
        } else {
          clearTagsBtn.classList.add("hidden");
        }
      }

      // Update UI when section selection changes
      function updateSectionUI() {
        sectionBtns.forEach((btn) => {
          const section = btn.getAttribute("data-section");
          const sectionObj = sections.find(s => s.name === section);
          
          if (section === currentSection) {
            btn.classList.add("bg-primary", "text-white", "active");
            btn.classList.remove("bg-background-offset", "text-text", "hover:bg-background-alt");
            
            if (sectionObj && sectionObj.color) {
              btn.style.backgroundColor = sectionObj.color;
              btn.style.color = "white";
            }
          } else {
            btn.classList.remove("bg-primary", "text-white", "active");
            
            if (sectionObj && sectionObj.color) {
              btn.style.backgroundColor = `${sectionObj.color}20`;
              btn.style.color = sectionObj.color;
            } else {
              btn.classList.add("bg-background-offset", "text-text", "hover:bg-background-alt");
            }
          }
        });
      }

      // Update UI when difficulty selection changes
      function updateDifficultyUI() {
        difficultyBtns.forEach((btn) => {
          const difficulty = btn.getAttribute("data-difficulty");
          const diffInfo = difficultyInfo[difficulty];
          
          if (difficulty === currentDifficulty) {
            btn.classList.add("bg-primary", "text-white", "active");
            btn.classList.remove("bg-background-offset", "text-text", "hover:bg-background-alt");
            
            // Override custom styles when active
            if (diffInfo) {
              btn.dataset.originalBgColor = diffInfo.bgColor;
              btn.dataset.originalColor = diffInfo.color;
              btn.style.backgroundColor = "var(--color-primary)";
              btn.style.color = "white";
            }
          } else {
            btn.classList.remove("bg-primary", "text-white", "active");
            
            // Restore custom styles
            if (diffInfo) {
              btn.style.backgroundColor = diffInfo.bgColor;
              btn.style.color = diffInfo.color;
            } else {
              btn.classList.add("hover:bg-primary/80");
            }
          }
        });
      }

      // Updated filtering function to include suggested tags and difficulty
      function applyFiltersAndSearch() {
        const selectedCategory = categoryFilter.value;
        const selectedCTF = ctfFilter.value;
        const searchTerm = searchInput.value.toLowerCase().trim();

        let visibleCount = 0;

        writeupCards.forEach((card) => {
          const category = card.getAttribute("data-category");
          const ctf = card.getAttribute("data-ctf");
          const section = card.getAttribute("data-section") || "";
          const tagsAttr = card.getAttribute("data-tags") || "[]";
          const suggestedTagsAttr = card.getAttribute("data-suggested-tags") || "[]";
          
          // Parse JSON strings into arrays
          const tags = tagsAttr ? JSON.parse(tagsAttr) : [];
          const suggestedTags = suggestedTagsAttr ? JSON.parse(suggestedTagsAttr) : [];
          
          // Combine both for matching
          const allTags = [...tags, ...suggestedTags];
          
          const slug = card.getAttribute("href").split("/").pop();

          const categoryMatch =
            !selectedCategory || category === selectedCategory;
          const ctfMatch = !selectedCTF || ctf === selectedCTF;
          const sectionMatch = !currentSection || section === currentSection;

          // Difficulty matching based on tags and sections
          let difficultyMatch = true;
          if (currentDifficulty) {
            // For PicoCTF or HTB sections, check for matching difficulty tag
            const relevantSections = ['PicoCTF', 'HackTheBox Machines', 'HackTheBox Challenges'];
            if (relevantSections.includes(section)) {
              difficultyMatch = tags.includes(currentDifficulty);
            } else {
              // For other sections, no difficulty filtering
              difficultyMatch = true;
            }
          }

          // Tag matching - check both regular tags and suggested tags
          const tagMatch =
            selectedTags.length === 0 ||
            selectedTags.some((tag) => allTags.includes(tag));

          // Search match - include suggested tags in search
          let searchMatch = true;
          if (searchTerm) {
            const indexEntry = searchIndex.find((entry) => entry.slug === slug);
            if (indexEntry) {
              // Handle tag-specific searches (starting with #)
              if (searchTerm.startsWith('#')) {
                const tagSearch = searchTerm.substring(1).toLowerCase();
                searchMatch = allTags.some(tag => tag.toLowerCase().includes(tagSearch));
              } else {
                // Regular search in all content
                const allSearchableContent = `${indexEntry.searchableText} ${suggestedTags.join(' ')}`;
                searchMatch = allSearchableContent.includes(searchTerm);
              }
            } else {
              searchMatch = false;
            }
          }

          if (
            categoryMatch &&
            ctfMatch &&
            sectionMatch &&
            difficultyMatch &&
            tagMatch &&
            searchMatch
          ) {
            card.classList.remove("hidden");
            visibleCount++;
          } else {
            card.classList.add("hidden");
          }
        });

        // Show/hide no results message
        if (visibleCount === 0) {
          writeupContainer.classList.add("hidden");
          noResultsMessage.classList.remove("hidden");
        } else {
          writeupContainer.classList.remove("hidden");
          noResultsMessage.classList.add("hidden");

          // Show search status if searching
          if (searchTerm) {
            searchStatus.innerHTML = `Found <span id="result-count" class="font-bold mx-1">${visibleCount}</span> results`;
            searchStatus.classList.remove("hidden");
          } else {
            searchStatus.classList.add("hidden");
          }
        }
      }

      // Reset all filters
      function resetFilters() {
        searchInput.value = "";
        categoryFilter.value = "";
        ctfFilter.value = "";
        selectedTags = [];
        currentSection = "";
        currentDifficulty = "";

        updateTagUI();
        updateSectionUI();
        updateDifficultyUI();
        applyFiltersAndSearch();
      }

      // Add event listeners
      categoryFilter?.addEventListener("change", applyFiltersAndSearch);
      ctfFilter?.addEventListener("change", applyFiltersAndSearch);
      searchInput?.addEventListener(
        "input",
        debounce(applyFiltersAndSearch, 300),
      );
      resetFiltersBtn?.addEventListener("click", resetFilters);

      // Clear tags button
      clearTagsBtn?.addEventListener("click", () => {
        selectedTags = [];
        updateTagUI();
        applyFiltersAndSearch();
      });

      // Section button clicks
      sectionBtns.forEach((btn) => {
        btn.addEventListener("click", () => {
          currentSection = btn.getAttribute("data-section");
          updateSectionUI();
          applyFiltersAndSearch();
        });
      });
      
      // Difficulty button clicks
      difficultyBtns.forEach((btn) => {
        btn.addEventListener("click", () => {
          currentDifficulty = btn.getAttribute("data-difficulty");
          updateDifficultyUI();
          applyFiltersAndSearch();
        });
      });

      // Tag button clicks
      tagBtns.forEach((btn) => {
        btn.addEventListener("click", () => {
          const tag = btn.getAttribute("data-tag");

          if (selectedTags.includes(tag)) {
            // Remove tag if already selected
            selectedTags = selectedTags.filter((t) => t !== tag);
          } else {
            // Add tag if not already selected
            selectedTags.push(tag);
          }

          updateTagUI();
          applyFiltersAndSearch();
        });
      });

      // Ensure the header always has the fixed-header class
      const header = document.getElementById("page-header");
      if (header) {
        header.classList.add("fixed-header");
      }
    </script>

    <style>
      /* Transitions for buttons */
      .section-btn,
      .tag-btn,
      .difficulty-btn {
        transition: all 0.2s ease-in-out;
      }

      /* Active states */
      .section-btn.active,
      .difficulty-btn.active {
        font-weight: 600;
      }

      .tag-btn:hover,
      .difficulty-btn:hover {
        transform: translateY(-1px);
      }
    </style>
  </body>
</html>